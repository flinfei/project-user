---
description: 
globs: 
alwaysApply: false
---
# 前端组件开发规范

## 说明
本规则适用于项目的前端组件开发。良好的组件设计和实现可以提高代码复用性、可维护性和可测试性，加快开发速度，提升用户体验。

## 组件设计原则

### 单一职责
- 每个组件应该只做一件事，遵循单一职责原则
- 如果一个组件变得复杂，应该考虑拆分为多个小组件
- 组件的职责应该清晰明确，易于理解

### 可复用性
- 组件应该设计为可复用的，避免硬编码和紧耦合
- 使用props传递数据和回调函数，而不是直接依赖外部状态
- 提供合理的默认值和类型检查，增强组件的健壮性

### 可测试性
- 组件应该易于测试，避免副作用和隐藏依赖
- 将复杂逻辑提取到hooks或工具函数中，便于单元测试
- 为关键组件编写测试用例，确保功能正确性

### 可维护性
- 组件代码应该清晰易懂，遵循项目编码规范
- 添加必要的注释，特别是对于复杂逻辑和特殊处理
- 避免过度优化导致的代码复杂性增加

## 目录结构

### 组件目录结构
```
components/
├── Button/
│   ├── index.tsx         # 主组件文件
│   ├── Button.module.css # 组件样式（如果使用CSS Modules）
│   ├── Button.test.tsx   # 组件测试
│   └── types.ts          # 组件类型定义（可选）
├── Card/
│   ├── index.tsx
│   ├── Card.module.css
│   ├── Card.test.tsx
│   └── components/       # 子组件目录（如果有）
│       ├── CardHeader.tsx
│       └── CardFooter.tsx
└── ...
```

### 页面组件目录结构
```
pages/
├── Home/
│   ├── index.tsx         # 页面主文件
│   ├── components/       # 页面特定组件
│   │   ├── Banner.tsx
│   │   └── FeatureList.tsx
│   ├── hooks/           # 页面特定hooks
│   │   └── useHomeData.ts
│   └── types.ts         # 页面类型定义
├── User/
│   ├── index.tsx
│   ├── components/
│   ├── hooks/
│   └── types.ts
└── ...
```

## 命名规范

### 组件命名
- 组件文件名使用大驼峰命名法（PascalCase），如 `Button.tsx`, `UserProfile.tsx`
- 组件名应该清晰表达其功能和用途，避免使用缩写
- 高阶组件使用 `with` 前缀，如 `withAuth.tsx`
- 自定义Hook使用 `use` 前缀，如 `useWindowSize.ts`

### Props命名
- Props名称使用小驼峰命名法（camelCase）
- 布尔类型的props应该使用 `is`, `has`, `should` 等前缀，如 `isDisabled`, `hasError`
- 事件处理props应该使用 `on` 前缀，如 `onClick`, `onSubmit`
- 事件处理函数应该使用 `handle` 前缀，如 `handleClick`, `handleSubmit`

### CSS类名命名
- 使用有意义的类名，反映元素的用途而非外观
- 使用连字符分隔的小写字母（kebab-case），如 `button-primary`, `card-header`
- 使用BEM命名规范：Block-Element--Modifier，如 `card__title`, `button--large`

## 组件实现规范

### 函数组件
- 优先使用函数组件和Hooks，而非类组件
- 使用解构获取props，提高代码可读性
- 使用TypeScript定义props类型，提供类型安全

```tsx
// 推荐写法
import React from 'react';
import { Button } from '@chakra-ui/react';

interface CardProps {
  title: string;
  description?: string;
  onAction?: () => void;
}

const Card: React.FC<CardProps> = ({ title, description, onAction }) => {
  return (
    <div className="card">
      <h3 className="card__title">{title}</h3>
      {description && <p className="card__description">{description}</p>}
      {onAction && (
        <Button onClick={onAction} colorScheme="blue">
          查看详情
        </Button>
      )}
    </div>
  );
};

export default Card;
```

### 状态管理
- 使用 `useState` 管理组件内部状态
- 使用 `useReducer` 管理复杂状态逻辑
- 使用 `useContext` 管理跨组件共享状态
- 对于全局状态，使用 Zustand 或其他状态管理库

```tsx
// 使用useState管理简单状态
const [isOpen, setIsOpen] = useState(false);

// 使用useReducer管理复杂状态
const [state, dispatch] = useReducer(reducer, initialState);

// 使用useContext管理共享状态
const { theme, setTheme } = useContext(ThemeContext);
```

### 副作用处理
- 使用 `useEffect` 处理副作用，如数据获取、订阅事件等
- 正确设置依赖数组，避免无限循环
- 在 `useEffect` 中返回清理函数，防止内存泄漏

```tsx
// 数据获取示例
useEffect(() => {
  let isMounted = true;
  
  const fetchData = async () => {
    try {
      setLoading(true);
      const data = await api.getData();
      if (isMounted) {
        setData(data);
      }
    } catch (error) {
      if (isMounted) {
        setError(error);
      }
    } finally {
      if (isMounted) {
        setLoading(false);
      }
    }
  };
  
  fetchData();
  
  return () => {
    isMounted = false;
  };
}, []);
```

## 性能优化

### 避免不必要的渲染
- 使用 `React.memo` 缓存组件，避免不必要的重渲染
- 使用 `useMemo` 缓存计算结果
- 使用 `useCallback` 缓存回调函数

```tsx
// 使用React.memo
const MemoizedComponent = React.memo(Component);

// 使用useMemo
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);

// 使用useCallback
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
```

### 懒加载
- 使用 `React.lazy` 和 `Suspense` 实现组件懒加载
- 对于大型页面，考虑使用路由级别的代码分割

```tsx
// 组件懒加载
const LazyComponent = React.lazy(() => import('./LazyComponent'));

// 在父组件中使用
<Suspense fallback={<div>Loading...</div>}>
  <LazyComponent />
</Suspense>
```

### 列表渲染优化
- 为列表项提供稳定的 `key` 属性，避免使用索引作为key
- 使用虚拟滚动处理大型列表，如 `react-window` 或 `react-virtualized`
- 避免在渲染函数中创建新函数或对象

## 样式管理

### 样式方案
- 优先使用 Chakra UI 组件库，遵循项目设计系统
- 对于自定义组件，使用 CSS Modules 或 Styled Components
- 避免内联样式，除非是动态计算的样式

### 响应式设计
- 使用 Chakra UI 的响应式属性实现响应式设计
- 使用相对单位（如rem、em、%）而非固定像素
- 使用媒体查询适配不同屏幕尺寸

### 主题定制
- 使用 Chakra UI 的主题系统进行全局样式定制
- 遵循设计系统中的颜色、字体、间距等规范
- 避免硬编码颜色值，使用主题变量

## 无障碍性（A11y）

### 基本要求
- 为图片提供有意义的 `alt` 属性
- 使用语义化HTML元素，如 `<button>`, `<nav>`, `<article>` 等
- 确保表单元素有关联的标签

### 键盘可访问性
- 确保所有交互元素可通过键盘访问
- 使用正确的标签和ARIA属性
- 测试键盘导航流程

### 颜色对比度
- 确保文本和背景之间有足够的对比度
- 不仅依赖颜色传达信息，同时使用形状、文本等
- 考虑提供高对比度模式

## 国际化（i18n）

### 文本管理
- 使用i18n库（如react-i18next）管理多语言文本
- 避免在组件中硬编码文本
- 使用翻译函数包装所有用户可见的文本

```tsx
// 使用i18n
import { useTranslation } from 'react-i18next';

const Component = () => {
  const { t } = useTranslation();
  
  return (
    <div>
      <h1>{t('welcome.title')}</h1>
      <p>{t('welcome.description')}</p>
    </div>
  );
};
```

### 日期和数字格式化
- 使用Intl API或格式化库处理日期和数字
- 考虑不同地区的日期格式（MM/DD/YYYY vs DD/MM/YYYY）
- 考虑不同地区的数字格式（小数点、千位分隔符）

## 错误处理

### 错误边界
- 使用错误边界（Error Boundaries）捕获组件树中的JavaScript错误
- 为关键功能区域添加单独的错误边界
- 提供友好的错误提示和恢复选项

### 加载状态
- 为异步操作提供明确的加载状态
- 使用骨架屏（Skeleton）代替简单的加载指示器
- 考虑部分加载状态，优先显示已加载的内容
